#!/usr/bin/env perl

############################################################################
# Copyright (c) 2016-2018 DBEI, UPENN
# All Rights Reserved
# See file LICENSE for details.
############################################################################

=begin SUMMARY
Main steps:
1. Check and record parameters designated by user
2. Record GC content in sliding windows for contigs
	key subroutine:
	&GC_count
3. Distribute SAM files to threads and calculate coverages in sliding windows
	key subroutine:
	&sam_cov_parallel
4. Convert COV2 (coverage in samples) to COV3 (coverage in contig clusters)
5. Distribute COV3 files to threads and invoke R to estimate growth rates
	key subroutine:
	&cov3_estPTR_parallel
6. Output
=cut

use strict;
use threads;
use Getopt::Long;
use File::Basename;

my $program = 'DEMIC';
my $version = '1.0.2';
my $dirname = dirname(__FILE__);

### Parameters that can be designated by user

my ( $sam_dir, $fasta_dir, $out_dir, $window_size, $window_step, $log, $help, $max_thread, $quiet, $output_all, $edge_length, $mapq_cutoff, $mapl_cutoff, $max_mismatch_ratio, $max_candidate_iter );
Getopt::Long::GetOptions (
	'sam_dir|S=s'				=>	\$sam_dir,
	'fasta_dir|F=s'				=>	\$fasta_dir,
	'out_dir|O=s'				=>	\$out_dir,

	'window_size|W=i'			=>	\$window_size,
	'window_step|D=i'			=>	\$window_step,
	'mapq_cutoff|M=i'			=>	\$mapq_cutoff,
	'mapl_cutoff|L=i'			=>	\$mapl_cutoff,
	'max_mismatch_ratio|R=f'	=>	\$max_mismatch_ratio,
	'max_candidate_iter|C=i'	=>	\$max_candidate_iter,

	'log|G=s'					=>	\$log,
	'help|H!'					=>	\$help,

	'thread_num|T=i'			=>	\$max_thread,
	'quiet|Q!'					=>	\$quiet,
	'output_all|A!'				=>	\$output_all,
);

if ( !defined($sam_dir) and !defined($fasta_dir) and !defined($out_dir) and !defined($window_size) and 
	!defined($window_step) and !defined($log) and !defined($help) and !defined($max_thread) and 
	!defined($quiet) and !defined($output_all) ) {
	print "Please use the --help or -H option to get usage information.\n";

### Show help info to user if requested

} elsif (defined($help)) {
	print "
Program:      $program
Description:  A computational tool for comparing bacterial growth rates
              between metagenomic samples
Version:      $version
Contact:      Yuan Gao <gaoyuan1\@mail.med.upenn.edu>

Usage:        perl $program.pl -S /input/sam_dir/ -F /input/fa_dir/ -O /output/dir/

Arguments:

    -S, --sam_dir
          directory of input SAM files generated by bowtie2 (required)
    -F, --fasta_dir
          directory of input FASTA files, each for a species (required)
    -O, --out_dir
          directory of output files (default: ./)

    -W, --window_size
          size (nt) of window for calculation of coverage (default: 5000)
    -D, --window_step
          step (nt) of window for calculation of coverage (default: 100)
    -M, --mapq_cutoff
          cutoff of mapping quality when calculating coverages (default: 5)
    -L, --mapl_cutoff
          cutoff of mapping length when calculating coverages (default: 50)
    -R, --max_mismatch_ratio
          maximum of mismatch ratio for each read as a hit (default: 0.03)

    -G, --log
          output log file name (optional)
    -H, --help
          show this help information

    -T, --thread_num
          set number of threads for parallel running (default: 1)
    -Q, --quiet
          keep quiet when running
    -A, --output_all
          keep the temporary files after running (more disk space would be 
          needed)

";
} else {

	my @die_reason;

	my $min_window_count = 5;
	my $min_cov_window = 0;

	if (!defined($quiet)) {
		$quiet = 'no';
	}

	# Check SAM directory and SAM files

	my @sam_readable;
	if ( !defined($sam_dir) ) {
		push @die_reason, "Please use --sam_dir or -S option to designate directory for SAM files!\n";
	} elsif ( !-e $sam_dir or !-d $sam_dir ) {
		push @die_reason, "SAM directory $sam_dir does not exist!\n";
	} elsif ( !-r $sam_dir ) {
		push @die_reason, "SAM directory $sam_dir is not readable!\n";
	} else {
		$sam_dir .= '/' if rindex($sam_dir, "/") != length($sam_dir) - 1;
		my @sam_files = <$sam_dir*.sam>;
		if (@sam_files == 0) {
			push @die_reason, "No file with suffix .sam is found in designated SAM directory.\n";
		}
		my ($check_limit, $m) = (100, 0);
		my $max_mapl = 0;
		my @not_bowtie2_sam;
		for my $sam (@sam_files) {
			$m ++;
			last if $m > $check_limit;
			if ( -r $sam ){
				my $not_bowtie2 == 0;
				my $test_num = 100;
				my $line_num = 0;
				open SAM, "<", $sam;
				while (<SAM>) {
					chomp;
					my @line = split /\t/;
					if (@line > 10) {
						$line_num ++;
						if ($line[5] > $max_mapl){
							$max_mapl = $line[5];
							my $mismatch = -1;
							for my $x (13, 14, 15, 12, 11){
								my @mismatches = split ':', $line[$x];
								if ($mismatches[0] eq 'XM') {
									$mismatch = $mismatches[2];
									last;
								}
							}
							$not_bowtie2 ++ if $mismatch == -1;
						}
						last if $line_num >= $test_num;
					}
				}
				close SAM;
				if ($line_num == $test_num) {
					push @sam_readable, $sam;
					push @not_bowtie2_sam, $sam if $not_bowtie2 > 0;
				}
				
			}
		}
		if (@sam_readable >= 1) {
			printf "Edge length with no coverage calculation for each contig is set as %g.\n", $max_mapl if $quiet eq 'no';
			$edge_length = $max_mapl;
			if (@not_bowtie2_sam >= 1) {
				push @die_reason, "The following SAM file(s) seem to be not generated by Bowtie2:\n@not_bowtie2_sam\n";
			}
		} else {
			push @die_reason, "No file with suffix .sam is readable and informative in designated SAM directory.\n";
		}
	}

	# Check FASTA directory and FASTA files

	if ( !defined($fasta_dir) ) {
		push @die_reason, "Please use --fasta_dir or -F option to designate directory for fasta files!\n";
	} elsif ( !-e $fasta_dir or !-d $fasta_dir ) {
		push @die_reason, "FASTA directory $fasta_dir does not exist!\n";
	} elsif ( !-r $fasta_dir ) {
		push @die_reason, "FASTA directory $fasta_dir is not readable!\n";
	} else {
		$fasta_dir .= '/' if rindex($fasta_dir, "/") != length($fasta_dir) - 1;
		my @fa_files = <$fasta_dir*.fa $fasta_dir*.fasta $fasta_dir*.fna $fasta_dir*.FA $fasta_dir*.FASTA $fasta_dir*.FNA>;
		if (@fa_files == 0) {
			push @die_reason, "No file with suffix .fa, .fasta or .fna is found in designated FASTA directory.\n";
		}
		my @fa_readable;
		for my $fa (@fa_files) {
			if ( -r $fa ){
				push @fa_readable, $fa;
			}
		}
		if (@fa_readable == 0) {
			push @die_reason, "No file with suffix .fa, .fasta or .fna is readable in designated FASTA directory.\n";
		}
	}

	# Check OUTPUT directory

	if ( !defined($out_dir) ) {
		print "OUTPUT directory is not designated. Use the current directory.\n" if $quiet eq 'no';
		$out_dir = './';
	} elsif ( !-e $out_dir or !-d $out_dir ) {
		print "OUTPUT directory $out_dir does not exist. Make it by myself.\n" if $quiet eq 'no';
		system "mkdir $out_dir";
	}
	if ( !-r $out_dir ) {
		push @die_reason, "OUTPUT directory $out_dir is not readable!\n";
	} elsif ( !-w $out_dir ) {
		push @die_reason, "OUTPUT directory $out_dir is not writable!\n";
	} elsif ( rindex($out_dir, "/") != length($out_dir) - 1 ) {
		$out_dir .= '/';
	}

	if ( !defined($max_candidate_iter) ) {
		$max_candidate_iter = 20;
	}

	# Check R script, lme4 and FactoMineR library

	my ($estPTR_script, $RTest) = ("/estGrowthRate$version.R", "/testR$version.R");
	my $estPTR_path = $dirname.$estPTR_script;
	my $RTest_path = $dirname.$RTest;

	if (!-e $estPTR_path) {
		push @die_reason, "R script $estPTR_path not found! Please keep it in the same directory with me.\n";
	} if (!-e $RTest_path) {
		push @die_reason, "R script $RTest_path not found! Please keep it in the same directory with me.\n";
	} else {
		my $R_out = $out_dir.$RTest.".out";
		my $testR_command = "Rscript $RTest_path $R_out";
		my $status = system($testR_command);
		my $exit_code = ($status >> 8) & 0xff;
		if ($exit_code != 0) {
			push @die_reason, "Please make sure R 3.3.1 or above with package \"lme4\" and \"FactoMineR\" has been installed already.\nNonzero exit code from testR script.\n";
		} elsif (!-e $R_out) {
			push @die_reason, "Please make sure R 3.3.1 or above with package \"lme4\" and \"FactoMineR\" has been installed already.\nNo output from testR script.\n";
		} else {
			open TESTR, "<", $R_out;
			my @R_info;
			while (<TESTR>) {
				chomp;
				push @R_info, $_;
			}
			if ($R_info[0] < 3 or ($R_info[0] == 3 and $R_info[1] < 3.1) or !defined $R_info[2] or !defined $R_info[3]) {
				push @die_reason, "Please make sure R 3.3.1 or above with package \"lme4\" and \"FactoMineR\" has been installed already.\n";
			}
		}
	}

	# Check sliding window size and window step size

	if (!defined $window_step) {
		print "Size of window step is not designated. Set it as 100.\n" if $quiet eq 'no';
		$window_step = 100;
	} elsif ($window_step > 1000) {
		push @die_reason, "Please choose a window step smaller than 1000!\n";
	} elsif ($window_step < 10) {
		push @die_reason, "Please choose a window step larger than 100!\n";
	} else {
		$window_step = int($window_step);
	}

	if (!defined $window_size) {
		print "Size of window is not designated. Set it as 5000.\n" if $quiet eq 'no';
		$window_size = 5000;
	} elsif ($window_size > 10000) {
		push @die_reason, "Please choose a window size smaller than 10000!\n";
	} elsif ($window_size < 500) {
		push @die_reason, "Please choose a window size larger than 500!\n";
	} else {
		$window_size = int($window_size);
	}

	if ($window_size < $window_step*2) {
		printf "Size of window ($window_size) is smaller twice of window_step ($window_step). Set it as twice (%g).\n", $window_step*2 if $quiet eq 'no';
		$window_size = $window_step*2;
	} elsif ($window_size % $window_step != 0) {
		printf "Size of window ($window_size) is not integral multiple of window_step ($window_step). Set it as %g.\n", int($window_size/$window_step)*$window_step if $quiet eq 'no';
		$window_size = int($window_size/$window_step)*$window_step;
	}

	# Check mapping quality and length cutoffs

	if (!defined $mapq_cutoff) {
		print "Cutoff of mapping quality is not designated. Set it as 5.\n" if $quiet eq 'no';
		$mapq_cutoff = 5;
	} elsif ($mapq_cutoff > 30) {
		push @die_reason, "Please choose a mapping quality cutoff smaller than 30!\n";
	} elsif ($mapq_cutoff < 0) {
		push @die_reason, "Please choose a non-negative mapping quality cutoff!\n";
	}

	if (!defined $mapl_cutoff) {
		print "Cutoff of mapping length is not designated. Set it as 50.\n" if $quiet eq 'no';
		$mapl_cutoff = 50;
	} elsif ($mapl_cutoff > 80) {
		push @die_reason, "Please choose a mapping length cutoff smaller than 80!\n";
	} elsif ($mapl_cutoff < 30) {
		push @die_reason, "Please choose a mapping length cutoff larger than 30!\n";
	}

	if (!defined $max_mismatch_ratio) {
		print "Maximum of mismatch ratio is not designated. Set it as 0.03.\n" if $quiet eq 'no';
		$max_mismatch_ratio = .03;
	} elsif ($max_mismatch_ratio > .3) {
		push @die_reason, "Please choose a maximum of mismatch ratio smaller than 0.3!\n";
	} elsif ($max_mismatch_ratio < 0.01) {
		push @die_reason, "Please choose a maximum of mismatch ratio larger than 0.01!\n";
	}
	
	# Check other parameters

	if (!defined($log)) {
		$log = $out_dir."$program.log";
	}
	
	if (!defined($output_all)) {
		$output_all = 'no';
	}

	if (!defined($max_thread)) {
		print "Thread number is not designated. Use single thread mode.\n" if $quiet eq 'no';
		$max_thread = 1;
	} elsif ( @sam_readable >=1 and $max_thread > @sam_readable ) {
		printf "Thread number designated is larger than number of readable SAM files. Set the former as the latter (%g).\n", scalar(@sam_readable) if $quiet eq 'no';
		$max_thread = @sam_readable;
	}
	
	# Die if fatal error found

	if (@die_reason >= 1){
		print @die_reason;
		print "Fatal error. Aborted.\n";
		die;
	}

	# Start running
	# Get array of SAM and FASTA files

	my ( @sams, @fastas);
	opendir SAM_IN, $sam_dir or die "cannot open directory $sam_dir: $!";
	for my $file ( readdir SAM_IN ) {
		if ( $file =~ /(^.+)\.sam$/i ) {
			push @sams, $file;
		}
	}
	closedir SAM_IN;

	opendir FA_IN, $fasta_dir or die "cannot open directory $fasta_dir: $!";
	for my $file ( readdir FA_IN ) {
		if ( $file =~ /(^.+)\.fasta$/i ) {
			push @fastas, $file;
		} elsif ( $file =~ /(^.+)\.fa$/i ) {
			push @fastas, $file;
		} elsif ( $file =~ /(^.+)\.fna$/i ) {
			push @fastas, $file;
		}
	}
	closedir FA_IN;

	# Record GC content in divided windows for contigs

	my (%GC_windows, %contig_len, %fasta_bin);

	for my $fasta (@fastas) {
		#print "$fasta\n" if $quiet eq 'no';
		$fasta =~ /(^.+)\.f\w*a$/i;
		my $fasta_ID = $1;
		my ($current_contig, $seq);

		open FA, "<", $fasta_dir.$fasta or die "cannot open $fasta_dir$fasta: $!";
		while (<FA>) {
			chomp;
			if (/^>/) {
				if (defined $current_contig) {

					my $len_contig = length($seq);
					if ($len_contig >= $window_size + 2*$edge_length) {

						my $window_sets = &window_setting( $len_contig );
						my $gc_info = &GC_count( $seq, $window_sets );
						$GC_windows{$current_contig} = $gc_info;
						$contig_len{$current_contig} = $len_contig;
						
					}
					$seq = '';
				}
				my @line = split /\s+/;
				$line[0] =~ /^>(.+$)/;
				$current_contig = $1;
				$fasta_bin{$current_contig} = $fasta_ID;
			} else {
				$seq .= $_;
			}
		}
		close FA;
		if (length($seq) >= $window_size + 2*$edge_length) {
			my $window_sets = &window_setting( length($seq) );
			my $gc_info = &GC_count( $seq, $window_sets );
			$GC_windows{$current_contig} = $gc_info;
			$contig_len{$current_contig} = length($seq);
		}
		$seq = '';
	}

	# Record each sam file and their size as hash, for next step of thread distribution

	my %sam_size;
	for my $sam (@sams) {
		my $size = -s $sam_dir.$sam;
		$sam_size{$sam} = $size;
	}

	# Distribute sam files to threads and begin parallel calculation of coverage

	my $sam_distr_ref = &thread_distribution( $max_thread, \%sam_size );

	my @ths;
	for my $th_ref (@{$sam_distr_ref}) {
		# $th_ref is the reference to the array of distributed sam files in this thread
		my $th = threads -> new({'context' => 'void'}, \&sam_cov_parallel, $th_ref);
		my $th_id = $th->tid();
		if ($quiet eq 'no' and $max_thread > 1) {
			print " Worker $th_id begins to scan: \n @{$th_ref}\n" if $quiet eq 'no';
		}
		unshift @ths, $th;
	}

	# Join the threads

	for (@ths) {
		my $th_id = $_->tid();
		$_ -> join();
		if ($quiet eq 'no' and $max_thread > 1) {
			print " Worker $th_id finished reporting.\n" if $quiet eq 'no';
		}
	}
	@ths = ();

	# Summarize to generate coverage file for each binned contigs

	print "Summarizing coverage for each bin/species.\n" if $quiet eq 'no';

	for my $fasta (@fastas) {
		$fasta =~ /(^.+)\.f\w*a$/i;
		my $fasta_ID = $1;
		if (-e $out_dir.$fasta_ID.'.cov3') {
			print $out_dir.$fasta_ID.'.cov3'." already exists. Overwrite it.\n" if $quiet eq 'no';
			system "rm $out_dir$fasta_ID.cov3";
		}
	}

	open LOG, ">", $log or die;
	my %cov3line;
	my %total_samples;
	for my $sam (@sams) {
		open COV2, "<", $out_dir.$sam.'.cov2' or die "cannot open $out_dir.$sam.cov2: $!";
		my $pre = '';
		while (<COV2>) {
			chomp;
			my @line = split /\t/;
			if ($pre ne $fasta_bin{$line[-1]}) {
				close COV3 if $pre ne '';
				open COV3, ">>", $out_dir.$fasta_bin{$line[-1]}.'.cov3' or die "cannot write to $out_dir$fasta_bin{$line[-1]}.cov3: $!";
			}

			$line[2] = 'Sample'.$line[2] if $line[2] =~ /^[0-9.]+$/;
			$total_samples{$line[2]} ++;
			print COV3 "$_," for @line;
			print COV3 "$contig_len{$line[-1]}\n";
			$cov3line{ $fasta_bin{$line[-1]} } ++;
			$pre = $fasta_bin{$line[-1]};
		}
		
		close COV3;
		close COV2;
	}
	close LOG;

	printf "Coverage calculation finished.\nDynamics estimation for %g species begins.\n", scalar(keys %cov3line) if $quiet eq 'no';

	# Check if previous log file exists before estimating PTR

	opendir OUTCHECK, $out_dir;
	for my $file (readdir OUTCHECK) {
		if ($file =~ /^\d+_ptr.log$/) {
			print $out_dir.$file." already exists. Delete it.\n" if $quiet eq 'no';
			system "rm $out_dir$file";
		}
	}
	closedir OUTCHECK;

	# Distribute sam files to threads and begin parallel estimation of growth rates

	my $cov3_distr_ref = &thread_distribution( $max_thread, \%cov3line );

	my $t = 0;
	for my $th_ref (@{$cov3_distr_ref}) {
		# $th_ref is the reference to the array of distributed sam files in this thread
		$t ++;
		my $th = threads -> new({'context' => 'void'}, \&cov3_estPTR_parallel, [$th_ref, $t]);
		my $th_id = $th->tid();
		if ($quiet eq 'no' and $max_thread > 1) {
			print " Worker $th_id begins to estimate growth dynamics for: \n @{$th_ref}\n" if $quiet eq 'no';
		}
		unshift @ths, $th;
	}

	# Join the threads

	for (@ths) {
		my $th_id = $_->tid();
		$_ -> join();
		if ($quiet eq 'no' and $max_thread > 1) {
			print " Worker $th_id finished reporting.\n" if $quiet eq 'no';
		}
	}
	@ths = ();

	print "$program finishes its work. Please see ${out_dir}all_PTR.txt for details.\n" if $quiet eq 'no';

	### Subroutine of invoking R for growth estimation from cov3 files
	### Speed has been optimized
	### Input the reference of cov3 files and id of a thread
	### No global variable is recorded here, all results will be output to file *_ptr.txt

	sub cov3_estPTR_parallel {
		my @argments = @{$_[0]};
		my @cov3s_th = @{$argments[0]};
		my @failed_files;
		for my $cov3s (@cov3s_th) {
			print "$cov3s\n" if $quiet eq 'no';
			my $input_R = $out_dir.$cov3s.'.cov3';
			my ($test_line_num, $valid_line_num, $n) = (10, 0, 0);
			open COV3IN, "<", $out_dir.$cov3s.'.cov3' or die "cannot write $cov3s.cov3: $!";
			while (<COV3IN>) {
				chomp;
				$n ++;
				my @line = split ',';
				if (@line >= 4) {
					$valid_line_num ++;
				}
				last if $n >= $test_line_num;
			}
			close COV3IN;
			if ($test_line_num == $valid_line_num) {
				#my $output_R = $out_dir.$cov3s.'_ptr.txt';
				my $output_R = $out_dir;
				my $ptr = $cov3s.'.ptr';
				my $command = "Rscript $estPTR_path $input_R $output_R $max_candidate_iter $ptr 2>>$log";
				my $status2 = system($command);
				my $exit_code2 = ($status2 >> 8) & 0xff;
				if ($exit_code2 != 0) {
					push @failed_files, $cov3s;
				} elsif (!-e $output_R) {
					push @failed_files, $cov3s;
				} 
			} else {
				push @failed_files, $cov3s;
			}
		}
		if (@failed_files > 0) {
			#record to log file if failing to estimate
			open FAIL, ">", $out_dir.$argments[1].'_ptr.log';
			print FAIL "Failed to process the following coverage files:\n@failed_files\n";
			close FAIL;
		}
	}

	### Subroutine of coverage calculation from sam
	### Speed has been optimized
	### Input the reference of sam files designated to a thread
	### No global variable is recorded here, all results will be output to file *.cov and *.cov2

	sub sam_cov_parallel {
		my @sams_th = @{$_[0]};
		for my $sam (@sams_th) {

			my $sample;
			if ($sam =~ /(^.+)\.fastq\.gz_sort\.sam$/i) {
				$sample = $1;
			} elsif ($sam =~ /(^.+)_sort\.sam$/i) {
				$sample = $1;
			} elsif ($sam =~ /(^.+)\.sam$/i) {
				$sample = $1;
			}
			
			print "$sam\n" if $quiet eq 'no';
			open SAM, "<", $sam_dir.$sam or die "cannot open $sam_dir.$sam: $!";
			open COV, ">", $out_dir.$sam.'.cov' or die "cannot write $sam.cov: $!";
			
			open COV2, ">", $out_dir.$sam.'.cov2' or die "cannot write $sam.cov2: $!";
			my $qualified_contig_ID = 0;

			my ($pre_contig, %coverages);

			while (<SAM>) {
				chomp;
				my @line = split /\t/;
				if (@line > 10) {
					#only calculate coverage for qualified contigs when all reads mapping to it have been recorded
					if (defined $pre_contig and $pre_contig ne $line[2]) {
						if (exists $contig_len{$pre_contig}) {
							my $cov_window_sum = 0;
							my (@cov_step);
							my $n = 0;
							my $first_i = ${$GC_windows{$pre_contig}}[0][0];
							my $last_i = ${$GC_windows{$pre_contig}}[-1][1];
							my $first_step = int(($first_i-1-$edge_length)/$window_step);
							my $last_step = int(($last_i-1-$edge_length)/$window_step);

							my @info_qualified;
							for my $step ( $first_step .. $last_step ) {

								#fill the coverage array and add to cov_window_sum
								if (exists $coverages{$step}) {
									push @cov_step, $coverages{$step};
									$cov_window_sum += $coverages{$step};
								} else {
									push @cov_step, 0;
								}
								#output and remove the oldest element from two arrays when the window is full.
								if ( @cov_step == int($window_size/$window_step) ) {
									$n ++;
									#check if the i corresponds to the window end calculated before;
									my $info = ${$GC_windows{$pre_contig}}[$n-1];
									my $window_last_i = ($step+1)*$window_step + $edge_length;
									my $window_first_i = $window_last_i - $window_size +1;
									die "$pre_contig: $step\t${$info}[1]\t$n-1" if $window_last_i != ${$info}[1];
									#output
									my $GC_window_sum = ${$info}[2];
									my $GC_window_diff = ${$info}[3];
									my $ave_cov_window = $cov_window_sum/$window_size;
									my $GC_content = $GC_window_sum/$window_size;
									printf COV "$pre_contig\t$window_first_i\t$window_last_i\t$cov_window_sum\t$window_size\t%.6f\t$GC_window_sum\t%.6f\t", $ave_cov_window, $GC_content;							
									if($GC_window_sum != 0){
										printf COV "$GC_window_diff\t%.6f\n", $GC_window_diff/$GC_window_sum;
									}else{
										print COV "$GC_window_diff\tNA\n";
									}
									$cov_window_sum -= shift @cov_step;
									if ($ave_cov_window > $min_cov_window) {
										my $info = sprintf("%.4f\t$GC_content\t$sample\t$pre_contig", log($ave_cov_window)/log(2));
										push @info_qualified, $info;
									}
									
								}
							}

							if( $n >= $min_window_count and @info_qualified == $n ){
								$qualified_contig_ID ++;
								printf COV2 "$_\n" for @info_qualified;
							}

						}
						%coverages = ();
					}
					$pre_contig = $line[2];
					
					#increment coverage for all related steps of each qualified read
					if ( exists $contig_len{$line[2]} and $line[4] >= $mapq_cutoff ) {
						
						#use a fast method to calculate and evaluate mapping length
						my $mapl;
						if (length($line[5]) <= 4) {
							$mapl = $line[5];
						} else {
							my $mapl_ref = &MSID($line[5], length($line[9]));
							$mapl = ${$mapl_ref}[-1];
						}

						my $mismatch = -1;
						for my $x (13, 14, 15, 12, 11){
							my @mismatches = split ':', $line[$x];
							if ($mismatches[0] eq 'XM') {
								$mismatch = $mismatches[2];
								last;
							}
						}
						die "Cannot find mismatch count in SAM record: $_" if $mismatch == -1;

						if ($mapl >= $mapl_cutoff and $mismatch <= $max_mismatch_ratio * $mapl){
							#step by step, with the first and the last steps treated differently
							my $start_step = int(($line[3]-1-$edge_length)/$window_step);
							my $end_step = int(($line[3]+$mapl-1-$edge_length)/$window_step);
							
							if ($start_step == $end_step) {
								$coverages{$start_step} += $mapl;
							} else {
								my $start_few = $window_step - (($line[3]-1-$edge_length) % $window_step);
								my $end_few = (($line[3]+$mapl-1-$edge_length) % $window_step);
								$coverages{$start_step} += $start_few;
								$coverages{$end_step} += $end_few;
								for my $step ( $start_step+1 .. $end_step-1 ) {
									$coverages{$step} += $window_step;
								}
							}
						}
					}
				} else {
					if (/^[@]SQ/) {
						my ($contig, $length);
						if ($line[1] =~ /^SN:(.+$)/) {
							$contig = $1;
						} if ($line[2] =~ /^LN:(\d+)/) {
							$length = $1;
						}

					}
				}
			}
			close SAM;
			#need to consider the last contig
			if (exists $contig_len{$pre_contig}) {
				my $cov_window_sum = 0;
				my (@cov_step);
				my $n = 0;
				my $first_i = ${$GC_windows{$pre_contig}}[0][0];
				my $last_i = ${$GC_windows{$pre_contig}}[-1][1];
				my $first_step = int(($first_i-1-$edge_length)/$window_step);
				my $last_step = int(($last_i-1-$edge_length)/$window_step);
				
				my @info_qualified;
				for my $step ( $first_step .. $last_step ) {

					#fill the coverage array and add to cov_window_sum
					if (exists $coverages{$step}) {
						push @cov_step, $coverages{$step};
						$cov_window_sum += $coverages{$step};
					} else {
						push @cov_step, 0;
					}
					#output and remove the oldest element from two arrays when the window is full.
					if ( @cov_step == int($window_size/$window_step) ) {
						$n ++;
						#check if the i corresponds to the window end calculated before;
						my $info = ${$GC_windows{$pre_contig}}[$n-1];
						my $window_last_i = ($step+1)*$window_step + $edge_length;
						my $window_first_i = $window_last_i - $window_size +1;
						die "$pre_contig: $step\t${$info}[1]\t$n-1" if $window_last_i != ${$info}[1];
						#output
						my $GC_window_sum = ${$info}[2];
						my $GC_window_diff = ${$info}[3];
						my $ave_cov_window = $cov_window_sum/$window_size;
						my $GC_content = $GC_window_sum/$window_size;
						printf COV "$pre_contig\t$window_first_i\t$window_last_i\t$cov_window_sum\t$window_size\t%.6f\t$GC_window_sum\t%.6f\t", $ave_cov_window, $GC_content;							
						if($GC_window_sum != 0){
							printf COV "$GC_window_diff\t%.6f\n", $GC_window_diff/$GC_window_sum;
						}else{
							print COV "$GC_window_diff\tNA\n";
						}
						$cov_window_sum -= shift @cov_step;
						if ($ave_cov_window > $min_cov_window) {
							my $info = sprintf("%.4f\t$GC_content\t$sample\t$pre_contig", log($ave_cov_window)/log(2));
							push @info_qualified, $info;
						}
									
					}
				}

				if( $n >= $min_window_count and @info_qualified == $n ){
					$qualified_contig_ID ++;
					printf COV2 "$_\n" for @info_qualified;
				}

			}
			%coverages = ();
			close COV;
			close COV2;
		}
	}

	### subroutine to return the start(-1) and end loci of all windows in a contig as reference of array

	sub window_setting {
		my $len_contig = $_[0];
		my @windows;
		my $window_num = int( ($len_contig - 2 * $edge_length - $window_size)/$window_step );
		for my $i ( 0 .. $window_num ) {
			$windows[$i] = [ $window_step * $i + $edge_length, $window_step * $i + $edge_length + $window_size ];
		}
		\@windows;
	}

	### Subroutine to return reference of array with info of all windows in a contig
	### The start loci, end loci, G+C and G-C are stored in the values of the hash as reference of array
	### Speed has been optimized
	### Input sequence of a contig and the reference of windows
	### Output the reference of window info array

	sub GC_count {
		my @windows = @{$_[1]};
		my $seq_mid = substr( $_[0], $windows[0][0], $windows[-1][1]-$windows[0][0] );
		my @window_info;
		my (@step_GpC, @step_GmC);
		my ($total_GpC, $total_GmC) = (0, 0);
		my $n = 0;
		for my $i (1 .. int(length($seq_mid)/$window_step)) {
			my $seq_step = substr( $seq_mid, ($i-1)*$window_step, $window_step );
			my @seq_array = split ('', "\U$seq_step");
			my %nt4count;
			for my $nt (@seq_array) {
				$nt4count{$nt} ++;
			}
			push @step_GpC, $nt4count{"G"} + $nt4count{"C"};
			push @step_GmC, $nt4count{"G"} - $nt4count{"C"};
			$total_GpC += $step_GpC[-1];
			$total_GmC += $step_GmC[-1];
			if ( @step_GpC == int($window_size/$window_step) ) {
				$n ++;
				push @window_info, [ $windows[$n-1][0]+1, $windows[$n-1][1], $total_GpC, $total_GmC ];
				$total_GpC -= shift @step_GpC;
				$total_GmC -= shift @step_GmC;
			}
		}
		die "$n\t".scalar(@windows) if $n != @windows;
		\@window_info;
	}

	### Subroutine to distribute files to threads according to their sizes
	### Input number of threads, and a hash with file names as keys and their sizes as values
	### Return the reference of an array with each element as the reference of distributed files for a thread

	sub thread_distribution {
		my $t = $_[0];
		my %file_size = %{$_[1]};	# e.g. 'SRR10000' => 1999999
		my @file_distributed;	# the array to return
		my @ordered_file = sort { $file_size{$b} <=> $file_size{$a} } (keys %file_size);
		my @thread_sum;

		for my $file (@ordered_file) {
			my ($min_thread, undef) = sort { $thread_sum[$a] <=> $thread_sum[$b] } (0 .. $t-1);
			push @{$file_distributed[ $min_thread ]}, $file;
			$thread_sum[ $min_thread ] += $file_size{$file};
		}
		\@file_distributed;
	}

	### The subroutine to decipher MSID values in SAM
	### All situations are considered, including those only in BWA-MEM
	### Input: 1.$_[0]: MSID value; 2.$_[1]: read length

	sub MSID {
		my $read_length = $_[1];
		my @counts = split /[MSIDH]/, $_[0];
		if (@counts == 1) {
			if ($_[0] eq "${read_length}M") {
				[0, 0, 0, $read_length];
			} else {
				[0, undef, undef, -1];
			}
		} else {
			$_[0] =~ s/H/S/g;
			my @styles = split /\d+/, $_[0];
			shift @styles;

			if (@counts == 2) {
				if ( $styles[0] eq 'M' and $styles[1] eq 'S' ) {
					[1, $counts[0], $counts[0]-1, $counts[0]];
				} elsif ( $styles[0] eq 'S' and $styles[1] eq 'M' ) {
					[-1, $counts[0], 0, $counts[1]];
				} else {
					[0, undef, undef, -2];
				}
			} elsif (@counts == 3) {
				if ( $styles[0] eq 'S' and $styles[2] eq 'S' ) {
					[10, $counts[0], $counts[2], $counts[1]];
				} elsif ( $styles[0] eq 'M' and $styles[1] eq 'D' and $styles[2] eq 'M' ) {
					[0, 0, 0, $read_length+$counts[1]];
				} elsif ( $styles[0] eq 'M' and $styles[1] eq 'I' and $styles[2] eq 'M' ) {
					[0, 0, 0, $read_length-$counts[1]];
				} else {
					[0, undef, undef, -2];
				}
			} elsif ( $styles[0] eq 'M' and $styles[-1] eq 'S' ) {
				my ($M_sum, $D_sum);
				for my $i (0 .. $#styles-1) {
					if ($styles[$i] eq 'M') {
						$M_sum += $counts[$i];
					} elsif ($styles[$i] eq 'D') {
						$D_sum += $counts[$i];
					}
				}
				if (!defined $D_sum) {
					[1, $read_length-$counts[-1], $M_sum-1, $M_sum];
				} else {
					[1, $read_length-$counts[-1], $M_sum+$D_sum-1, $M_sum+$D_sum];
				}
			} elsif ( $styles[0] eq 'S' and $styles[-1] eq 'M' ) {
				my ($M_sum, $D_sum);
				for my $i (1 .. $#styles) {
					if ($styles[$i] eq 'M') {
						$M_sum += $counts[$i];
					} elsif ($styles[$i] eq 'D') {
						$D_sum += $counts[$i];
					}
				}
				if (!defined $D_sum) {
					[-1, $counts[0], 0, $M_sum];
				} else {
					[-1, $counts[0], 0, $M_sum+$D_sum];
				}
			} elsif ( $styles[0] eq 'M' and $styles[-1] eq 'M' ) {
				my ($M_sum, $D_sum);
				for my $i (0 .. $#styles) {
					if ($styles[$i] eq 'M') {
						$M_sum += $counts[$i];
					} elsif ($styles[$i] eq 'D') {
						$D_sum += $counts[$i];
					}
				}
				if (!defined $D_sum) {
					[0, 0, 0, $M_sum];
				} else {
					[0, 0, 0, $M_sum+$D_sum];
				}
			} elsif ( $styles[0] eq 'S' and $styles[-1] eq 'S' ) {
				my ($M_sum, $D_sum);
				for my $i (1 .. $#styles-1) {
					if ($styles[$i] eq 'M') {
						$M_sum += $counts[$i];
					} elsif ($styles[$i] eq 'D') {
						$D_sum += $counts[$i];
					}
				}
				if (!defined $D_sum) {
					[10, $counts[0], $counts[-1], $M_sum];
				} else {
					[10, $counts[0], $counts[-1], $M_sum+$D_sum];
				}
			} else {
				[0, undef, undef, -2];
			}
		}
	}

}
